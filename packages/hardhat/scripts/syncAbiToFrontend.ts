/**
 * ç›´æ¥ä» artifacts åŒæ­¥ ABI åˆ°å‰ç«¯
 * è¿™ä¸ªè„šæœ¬ä» hardhat artifacts è¯»å–ç¼–è¯‘åçš„åˆçº¦ ABIï¼Œ
 * å¹¶å°†å…¶åŒæ­¥åˆ° Next.js å‰ç«¯çš„ contracts æ–‡ä»¶å¤¹
 */

import * as fs from "fs";
import * as path from "path";
import prettier from "prettier";

const ARTIFACTS_DIR = "./artifacts/contracts";
const DEPLOYMENTS_DIR = "./deployments/localhost";
const TARGET_DIR = "../nextjs/contracts/";

interface ContractArtifact {
  abi: any[];
  bytecode: string;
  deployedBytecode: string;
}

interface DeploymentInfo {
  address: string;
  abi: any[];
}

async function syncAbiToFrontend() {
  console.log("ğŸ”„ Starting ABI sync from artifacts to frontend...");

  // è¯»å–éƒ¨ç½²ä¿¡æ¯ä»¥è·å–åˆçº¦åœ°å€
  const deployments: Record<string, DeploymentInfo> = {};
  
  if (fs.existsSync(DEPLOYMENTS_DIR)) {
    const files = fs.readdirSync(DEPLOYMENTS_DIR);
    
    for (const file of files) {
      if (file.endsWith(".json") && file !== ".chainId") {
        const contractName = file.replace(".json", "");
        const deploymentPath = path.join(DEPLOYMENTS_DIR, file);
        const deployment = JSON.parse(fs.readFileSync(deploymentPath, "utf-8"));
        
        deployments[contractName] = {
          address: deployment.address,
          abi: deployment.abi,
        };
        
        console.log(`âœ… Found deployment: ${contractName} at ${deployment.address}`);
      }
    }
  }

  // è¯»å–é“¾ ID
  const chainIdPath = path.join(DEPLOYMENTS_DIR, ".chainId");
  const chainId = fs.existsSync(chainIdPath) 
    ? fs.readFileSync(chainIdPath, "utf-8").trim() 
    : "1337";

  console.log(`ğŸ“¡ Chain ID: ${chainId}`);

  // æ„å»ºè¾“å‡ºå¯¹è±¡
  const output: Record<string, any> = {};
  output[chainId] = {};

  for (const [contractName, deployment] of Object.entries(deployments)) {
    output[chainId][contractName] = {
      address: deployment.address,
      abi: deployment.abi,
      inheritedFunctions: {},
      deployedOnBlock: 0,
    };
  }

  // ç”Ÿæˆ TypeScript æ–‡ä»¶
  const fileContent = Object.entries(output).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");

  const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
  }

  const targetPath = path.join(TARGET_DIR, "deployedContracts.ts");
  
  const formattedContent = await prettier.format(
    `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`,
    {
      parser: "typescript",
    }
  );

  fs.writeFileSync(targetPath, formattedContent);

  console.log(`ğŸ“ Successfully updated ${targetPath}`);
  console.log(`âœ¨ ABI sync complete!`);
  
  // éªŒè¯æ–°å‡½æ•°æ˜¯å¦å­˜åœ¨
  const contractNames = Object.keys(deployments);
  for (const contractName of contractNames) {
    const abi = deployments[contractName].abi;
    const functionNames = abi
      .filter((item: any) => item.type === "function")
      .map((item: any) => item.name);
    
    console.log(`\nğŸ“‹ ${contractName} functions (${functionNames.length} total):`);
    console.log(`   ${functionNames.slice(0, 10).join(", ")}${functionNames.length > 10 ? "..." : ""}`);
    
    // æ£€æŸ¥å…³é”®å‡½æ•°
    const keyFunctions = ["pauseListing", "resumeListing", "makeOffer", "acceptOffer", "getOffers"];
    const foundFunctions = keyFunctions.filter(fn => functionNames.includes(fn));
    
    if (foundFunctions.length > 0) {
      console.log(`   âœ… Found new functions: ${foundFunctions.join(", ")}`);
    }
  }
}

syncAbiToFrontend()
  .then(() => {
    console.log("\nğŸ‰ Done!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("âŒ Error:", error);
    process.exit(1);
  });
